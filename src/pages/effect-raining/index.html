{% extends 'base.html' %}

<title>Raining</title>

<style>
    body {
        overflow: hidden;
    }

    canvas {
        width: 100%;
        height: 100%;
        background-color: rgb(4, 4, 43);
    }
</style>

<html>
<canvas id="canvas"></canvas>

</html>

<script>
    var canvas = document.querySelector('canvas');
    var ctx = canvas.getContext('2d');

    function resize(canvas2) {
        const displayWidth = canvas2.clientWidth;
        const displayHeight = canvas2.clientHeight;
        if (canvas2.width != displayWidth) {
            canvas2.width = displayWidth;
        }
        if (canvas2.height != displayHeight) {
            canvas2.height = displayHeight;
        }
    }

    var drops = [];

    for (let i = 0; i < 100; i++) {
        drops.push({
            t: Math.random(),
            deg: Math.random() * Math.PI
        });
    }

    var particles = [];
    var CY = -300;
    var RAIN_LENGTH = 0.1;
    var circleR = 800;
    var t = 0;
    var forward = true;

    function redraw(_timestamp, diff) {
        resize(canvas);
        circleR = canvas.height * 4;
        CY = -circleR * 3 / 4;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 0.5;
        ctx.save();
        ctx.translate(canvas.width / 2, CY);
        if (forward) {
            t += diff / 2e3;
        } else {
            t -= diff / 2e3;
        }
        t = 1;
        ctx.beginPath();

        for (const drop of drops) {
            const x1 = Math.cos(drop.deg) * drop.t * circleR;
            const x2 = Math.cos(drop.deg) * (drop.t + RAIN_LENGTH) * circleR;
            const y1 = Math.sin(drop.deg) * drop.t * circleR;
            const y2 = Math.sin(drop.deg) * (drop.t + RAIN_LENGTH) * circleR;
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            drop.t += diff / 800;
            if (drop.t > 1) {
                if (Math.random() < 0.2) {
                    particles.push({
                        x: Math.cos(drop.deg) * circleR * 0.95,
                        y: Math.sin(drop.deg) * circleR * 0.95,
                        t: 0,
                        deg: drop.deg + Math.PI
                    });
                }
                drop.t = Math.random() - 0.5;
                drop.deg = Math.random() * Math.PI;
            }
        }
        ctx.closePath();
        ctx.stroke();
        particles.forEach((particle, index) => {
            ctx.fillStyle = 'white';
            const rev = -1 * Math.pow(particle.t - 0.5, 2) * circleR * 0.05 - circleR * 0.04;
            ctx.fillRect(Math.cos(particle.deg) * rev + particle.x, Math.sin(particle.deg) * rev + particle.y, 3, 3);
            particle.t += diff / 300;
            if (particle.t > 1) {
                particles.splice(index, 1);
            }
        });
        ctx.restore();
    }
    var start;
    var before;
    function step(timestamp) {
        if (start === void 0) {
            start = timestamp;
        }
        const elapsed = timestamp - start;
        if (before === void 0) {
            before = elapsed;
        }
        redraw(elapsed, elapsed - before);
        before = elapsed;
        requestAnimationFrame(step);
    }

    requestAnimationFrame(step);
</script>
